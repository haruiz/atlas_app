import { A2AMiddlewareAgent } from "@ag-ui/a2a-middleware"
import {CopilotRuntime, copilotRuntimeNextJSAppRouterEndpoint, ExperimentalEmptyAdapter} from "@copilotkit/runtime";
import {AbstractAgent, HttpAgent} from "@ag-ui/client";
import {NextRequest} from "next/server";



export async function POST(request: NextRequest) {
// These first two are the urls to the a2a agents
const weatherAgentUrl = process.env.WEATHER_AGENT_URL || "http://localhost:8002";
const mapsAgentUrl = process.env.MAPS_AGENT_URL || "http://localhost:8001";
const orchestratorUrl = process.env.ORCHESTRATOR_URL || "http://localhost:8000";

// the orchestrator agent we pass to the middleware needs to be an instance of a derivative of an ag-ui `AbstractAgent`
// In this case, we have access to the agent via url, so we can gain an instance using the `HttpAgent` class
const orchestrationAgent: AbstractAgent = new HttpAgent({
  url: orchestratorUrl,
});

// A2A Middleware: Wraps orchestrator and injects send_message_to_a2a_agent tool
// This allows orchestrator to communicate with A2A agents transparently
const a2aMiddlewareAgent = new A2AMiddlewareAgent({
  description:
    "An orchestrator agent that coordinates two specialized agents: Weather Agent and Maps Agent build on the ADK framework.",
  // We pass the urls to the a2a agents, the middleware will handle the connections
  agentUrls: [
    weatherAgentUrl,
    mapsAgentUrl,
  ],
  // Pass the agent instance
  orchestrationAgent,
  // These are domain specific instructions for the agent. They will be added to the generic instructions on how to
  // connect to a2a agents that will be automatically generated by the middleware
  instructions: `
    You are an orchestrator agent that will coordinate 2 specialized agents.
    
    AVAILABLE AGENTS:
    
    * Weather Agent (ADK): Provides weather information for specified locations
    * Maps Agent (ADK): Provides geographic coordinates, place lookups, and directions
    
    WORKFLOW STRATEGY (SEQUENTIAL - ONE AT A TIME):
    
    When the user asks for weather information:
    
    1. Maps Agent – First, resolve the place name into coordinates
    
    * Pass: The user's location or place name
    * The agent will return structured JSON with latitude and longitude
    
    2. Weather Agent – Then, fetch the weather for that location
    
    * Pass: The coordinates returned by the Maps Agent
    * The agent will return structured JSON with weather data
    
    3. Present the complete location resolution and weather summary to the user
    
    When the user asks for map or location information:
    
    1. Maps Agent – Retrieve coordinates, directions, or map details
    
    * Pass: The place name or map-related request
    * The agent will return structured JSON with the requested mapping information
    
    2. Present the map results to the user
    
    CRITICAL RULES:
    
    * Call agents ONE AT A TIME, wait for results before making next call
    * Pass information from earlier agents to later agents when required
    * Synthesize all gathered information in the final response
  `,
});

// CopilotKit runtime connects frontend to agent system
  // CopilotKit runtime connects frontend to agent system
  const runtime = new CopilotRuntime({
    agents: {
      a2a_chat: a2aMiddlewareAgent, // Must match agent prop in <CopilotKit agent="a2a_chat">
    },
  });

  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({
    runtime,
    serviceAdapter: new ExperimentalEmptyAdapter(),
    endpoint: "/api/copilotkit",
  });

  return handleRequest(request);
}
